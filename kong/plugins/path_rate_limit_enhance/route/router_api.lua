---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by WangChen.
--- DateTime: 2022/7/21 11:11
---

local cjson = require "cjson.safe"


local setmetatable              = setmetatable
local error                     = error
local type                      = type
local ngx                       = ngx
local shared                    = ngx.shared
local router_shared_memory_name = "router_shared_cache"


local _M = {}


function _M:buildKey(route_id, tenant_id)
    return route_id .. tenant_id
end


function _M:store(key, router_tree)
    if type(key) ~= "string" or type(router_tree) ~= "table" then
        return false, "key or router_tree not right"
    end
    local router_tree_json = cjson.encode(router_tree)
    return self:_store(key, router_tree_json)
end


function _M:_store(key, router_tree_json)
    if type(key) ~= "string" or type(router_tree_json) ~= "string" then
        return false, "key or router_tree_json must be a string"
    end
    if not router_tree_json then
        return false, "could not encode router_tree object"
    end
    local success, err = self.dict:safe_set(key, router_tree_json, 0)
    if not success then
        ngx.say(ngx.ERR, "rate limit set router tree fail ! " .. err .. " please increase the shared cache size")
    end
    return success, err
end


function _M:cover(key, router_tree)
    if type(key) ~= "string"then
        return false, "key must be string"
    end
    local router_tree_json = cjson.encode(router_tree)
    local exist, err = self.dict:replace(key, router_tree_json, 0)
    if not exist then
        return self:_store(key, router_tree_json)
    end
    return exist, err
end


function _M:fetch(key)
    if type(key) ~= "string"then
        return false, "key must be string"
    end
    local router_tree_json, err = self.dict:get(key)
    if not router_tree_json then
        if not err then
            return nil, key .. " router tree object not in cache"
        else
            return nil, err
        end
    end

    local router_tree = cjson.decode(router_tree_json)
    if not router_tree then
        return nil, key .. " could not decode router tree object"
    end

    return router_tree
end


function _M:delete(key)
    if type(key) ~= "string"then
        return false, "key must be string"
    end
    self.dict:delete(key)
end


function _M:fetch_json(key)
    if type(key) ~= "string"then
        return false, "key must be string"
    end
    local router_tree_json, err = self.dict:get(key)
    if not router_tree_json then
        if not err then
            return nil, key .. " router tree object not in cache"
        else
            return nil, err
        end
    end
    return router_tree_json
end


function _M:new()
    local dict = shared[router_shared_memory_name]

    if not dict then
        ngx.say(ngx.ERR, "name router_shared_cache shared memory not found !")
        error("name router_shared_cache shared memory not found", 2)
    end

    local self = {
        dict = dict,
    }
    return setmetatable(self, {
        __index = _M,
    })
end


return _M